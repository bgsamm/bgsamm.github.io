<!DOCTYPE html>
<html lang="en">
<head>
        <title>Site design - My Webpage</title>
    <link rel="stylesheet" href="styles/base.css" />

    <link rel="stylesheet" href="styles/page.css" />
</head>
<body>
    <div id="content">    <div id="content"><h1>Design overview</h1><h3>Principles</h3><p>The following are the primary "mantras" I am keeping in mind as I build this site:</p><ol><li><strong>Have fun with it</strong> - This website is meant as a creative outlet and means of personal expression, so my own enjoyment and interest will always take priority over concerns like practicality.</li><li><strong>Put a pin in it</strong> - I always want to be able to put a project down if my interests have shifted, with the knowledge that I have systems in place to facilitate picking up where I left off in the future.</li><li><strong>Reinvent the wheel</strong> - I find reimplementing something (if it's something I'm interested in) far more rewarding and instructive than using someone else's solution, even if the final result is of inferior quality.</li><li><strong>"Good enough" is good enough</strong> - I want systems for leaving something incomplete or imperfect, and for recording how I might like to improve it or extend it in the future (similar to 2)</li><li><strong>Make it public</strong> - I want to err on the side of expressing interests, making mistakes, and being wrong out in the open.</li><li><strong>Don't be silly, wrap your‚Ä¶ dependencies</strong> - Always wrap dependencies to make them easy to replace later!</li><li><strong>Follow the data</strong> - Programs should always be designed around the data they manipulate.</li></ol><h3>Non-goals</h3><p>The following are explicit non-goals of this project, meaning I am intentionally deprioritizing them:</p><ol><li><strong>Mobile friendly design</strong> - Fuck phones.</li><li><strong>Cross-browser compatibility</strong> - I'm not going to stress about making sure the website looks and functions identically across all versions of all browsers on all platforms. As long as it looks good on the latest version of FireFox, I'm content.</li><li><strong>Production-quality code</strong> - While it's great if others find my code useful, I make no claims as to its robustness nor commitments to its maintenance.</li></ol><h2>Site infrastructure</h2><h1>Build system</h1><p>This build system generates a static site from Emacs <a href="https://orgmode.org/">Org</a> files using <a href="https://boisgera.github.io/pandoc/">Pandoc</a> to convert said files to HTML, and <a href="https://jinja.palletsprojects.com/en/stable/">Jinja</a> for generating pages from templates.</p><p>While it could have been possible to use the <code>Pandoc</code> executable directly with filters and templates, that approach couples me more tightly to <code>Pandoc</code>, which I consider undesirable (see 4).</p><h2>Program outline</h2><p>The overall structure of the program is as follows:</p><figure><pre><code>&lt;&lt;Imports&gt;&gt;

&lt;&lt;Global constants&gt;&gt;

&lt;&lt;Function definitions&gt;&gt;

&lt;&lt;Set up Jinja environment&gt;&gt;

&lt;&lt;Ensure build directory exists&gt;&gt;

&lt;&lt;Copy static files to build directory&gt;&gt;

&lt;&lt;Process org files&gt;&gt;

&lt;&lt;Generate home page&gt;&gt;
</code></pre></figure><h2>Processing Org files</h2><p>To start, we must walk the directory containing our Org files and process each one.</p><figure><pre><code>import os
</code></pre></figure><figure><pre><code>PAGES_DIR = 'pages'
</code></pre></figure><figure><pre><code>def walk_directory(root, extension='*'):
    for dirpath, dirnames, filenames in os.walk(root):
        for filename in filenames:
            fname, ext = os.path.splitext(filename)
            if extension == '*' or ext == extension:
                yield dirpath, fname, ext

</code></pre></figure><figure><figcaption>Process org files</figcaption><pre><code>pages = []
for dirpath, fname, ext in walk_directory(PAGES_DIR, extension='.org'):
    &lt;&lt;Process org file&gt;&gt;
</code></pre></figure><p>Processing an Org file involves parsing it into an abstract syntax tree, converting that tree into an HTML string, then using that HTML string (and any other relevant metadata) to populate a static page template.</p><figure><figcaption>Process org file</figcaption><pre><code>&lt;&lt;Parse org file into AST&gt;&gt;

&lt;&lt;Generate page content from AST&gt;&gt;

&lt;&lt;Create page from template&gt;&gt;

&lt;&lt;Write page to file&gt;&gt;
</code></pre></figure><h2>Parsing an Org file</h2><p>Currently, I am using Pandoc to perform the initial reading and parsing of an Org file. I still perform a second filtering pass over its output, however, both to keep from exposing its types to the rest of the build system, and to gain greater control over the final representation since things like to-do's are not handled well out-of-the-box.</p><figure><figcaption>Parse org file into AST</figcaption><pre><code>fpath = path_join(dirpath, fname + ext)
ast = parse_org_file(fpath)

metadata = ast[0]
</code></pre></figure><figure><pre><code>import pandoc
</code></pre></figure><figure><pre><code>def parse_org_file(fpath):
    ast = pandoc.read(file=fpath)

    &lt;&lt;Unwrap metadata&gt;&gt;

    &lt;&lt;Unwrap blocks&gt;&gt;

    return tuple(ast)

</code></pre></figure><p>Every Org file in this repository starts with a property drawer that defines its metadata, like title, author, date, etc. This is stored as the first element of the root <code>Pandoc</code> object, as a <code>Meta</code> object containing a dictionary of (<code>str</code>, <code>MetaString</code>) pairs.</p><figure><figcaption>Unwrap metadata</figcaption><pre><code># Unwrap 'Meta' object
metadata = ast[0][0]
for k, v in metadata.items():
    # Unwrap 'MetaString' object
    metadata[k] = v[0]

ast[0] = metadata
</code></pre></figure><p>The second element of the root <code>Pandoc</code> object is a list of <code>Block</code> objects, which represent each of the individual blocks in the Org file as one of several different subtypes (e.g. <code>Header</code>, <code>Para</code>, <code>CodeBlock</code>, etc.). Filters for each block type are added and expanded on an as-needed basis.</p><figure><figcaption>Unwrap blocks</figcaption><pre><code>ast[1] = unwrap_blocks(ast[1])
</code></pre></figure><figure><pre><code>def unwrap_blocks(blocks):
    return [unwrap_block(block) for block in blocks]

</code></pre></figure><figure><pre><code>def unwrap_block(block):
    pandoc_type = type(block)
    if pandoc_type is pandoc.types.RawBlock:
        &lt;&lt;Unwrap RawBlock&gt;&gt;
    elif pandoc_type is pandoc.types.Header:
        &lt;&lt;Unwrap Header&gt;&gt;
    elif pandoc_type is pandoc.types.Para:
        node_type = 'paragraph'
        node_attrs = { 'children': unwrap_blocks(block[0]) }
    elif pandoc_type is pandoc.types.Plain:
        node_type = 'plain-text'
        node_attrs = { 'children': unwrap_blocks(block[0]) }
    elif pandoc_type is pandoc.types.Strong:
        node_type = 'strong-text'
        node_attrs = { 'children': unwrap_blocks(block[0]) }
    elif pandoc_type is pandoc.types.Emph:
        node_type = 'emphasized-text'
        node_attrs = { 'children': unwrap_blocks(block[0]) }
    elif pandoc_type is pandoc.types.OrderedList:
        &lt;&lt;Unwrap OrderedList&gt;&gt;
    elif pandoc_type is pandoc.types.CodeBlock:
        &lt;&lt;Unwrap CodeBlock&gt;&gt;
    elif pandoc_type is pandoc.types.Code:
        &lt;&lt;Unwrap Code&gt;&gt;
    elif pandoc_type is pandoc.types.Link:
        &lt;&lt;Unwrap Link&gt;&gt;
    elif pandoc_type is pandoc.types.Span:
        &lt;&lt;Unwrap Span&gt;&gt;
    elif pandoc_type is pandoc.types.Str:
        node_type = 'string'
        node_attrs = { 'text': block[0] }
    elif pandoc_type is pandoc.types.Space:
        node_type = 'space'
        node_attrs = {}
    elif pandoc_type is pandoc.types.SoftBreak:
        node_type = 'soft-break'
        node_attrs = {}
    else:
        raise TypeError(f'Unhandled block type: {pandoc_type}')

    &lt;&lt;Special case for TODO items&gt;&gt;

    return (node_type, node_attrs)

</code></pre></figure><p>Because <code>TODO</code> items are represented in an Org mode using the same syntax as headings, they end up getting parsed as a <code>Span</code> in either a <code>Header</code> or a <code>Para</code> object's <code>Inline</code> tokens (since Pandoc exports headings deeper than <code>org-export-headline-levels</code> as paragraphs).</p><p>Additionally, there appears to be a bug in the way Pandoc handles an ordered list following one or more TODO items - it groups the TODOs in an ordered list, then adds the following ordered list as a sublist.</p><p>To address these issues, a special case is added to catch such <code>TODO</code> items and convert them to the proper node type.</p><figure><figcaption>Special case for TODO items</figcaption><pre><code>if node_type == 'heading' or node_type == 'paragraph':
    children = node_attrs['children']
    assert(len(children) &gt; 0)
    first_child_type, first_child_attrs = children[0]
    if first_child_type == 'span' and first_child_attrs['is-todo']:
        node_type = 'todo-item'
        children[0] = first_child_attrs['children'][0]
</code></pre></figure><p><code>RawBlock</code> objects contain the block format (expected to be 'org') and the block text. All we care about is the text, which we perform a regular expression match on to determine the raw block's type.</p><figure><pre><code>import re
</code></pre></figure><figure><pre><code>def regex_match(pattern, string):
    match_obj = re.match(pattern, string)
    if match_obj is not None:
        return match_obj.groups()
    return None

</code></pre></figure><figure><figcaption>Unwrap RawBlock</figcaption><pre><code>assert(block[0][0] == 'org')
matches = regex_match(r'#\+(\w+):\s+(.+)', block[1])
assert(matches is not None)
node_type = 'org-directive'
node_attrs = {
    'type': matches[0].lower(),
    'value': matches[1]
}
</code></pre></figure><p><code>Header</code> objects contain the header level (1, 2, 3, etc.), an <code>Attr</code> tuple of the form (id, classes, attributes), and then a list representing the parsed header tokens (type <code>Inline</code>). These must be unwrapped recursively.</p><figure><figcaption>Unwrap Header</figcaption><pre><code>assert(block[1][1] == [] and block[1][2] == [])
node_type = 'heading'
node_attrs = {
    'level': block[0],
    'children': unwrap_blocks(block[2])
}
</code></pre></figure><p>An <code>OrderedList</code> contains a tuple of list attributes of the form (start, style, delim), then a list of the list's items (each of which is itself a list of blocks).</p><figure><figcaption>Unwrap OrderedList</figcaption><pre><code>node_type = 'ordered-list'
node_attrs = {
    'start': block[0][0],
    'style': str(block[0][1])[:-2], # Strip trailing parens
    'delim': str(block[0][2])[:-2], # ""
    'children': [(
        'list-item',
        { 'children': unwrap_blocks(item) }
    ) for item in block[1]]
}
</code></pre></figure><p>Code blocks are represented by <code>CodeBlock</code> objects, which consist of an <code>Attr</code> tuple and the contained code (text). The language is specified in the class list of the <code>Attr</code> tuple.</p><figure><figcaption>Unwrap CodeBlock</figcaption><pre><code>assert(len(block[0][1]) == 1)
node_type = 'code-block'
node_attrs = {
    'name': block[0][0],
    'language': block[0][1][0],
    'text': block[1]
}
</code></pre></figure><p>Inline code blocks are represented by <code>Code</code> objects and consist of an <code>Attr</code> tuple and the contained code (text).</p><figure><figcaption>Unwrap Code</figcaption><pre><code>assert(block[0][0] == '' and block[0][2] == [])
assert(len(block[0][1]) == 1 and block[0][1][0] == 'verbatim')
node_type = 'inline-code'
node_attrs = {
    'text': block[1]
}
</code></pre></figure><p><code>Link</code> objects contain an <code>Attr</code> tuple (currently ignored), a list of <code>Inline</code> tokens (the link text), and the link's <code>Target</code> (a 2-tuple).</p><p>I am currently ignoring the second element of the <code>Target</code>, which I <em>believe</em> to be a title or description and which is likely unused by Org files.</p><figure><figcaption>Unwrap Link</figcaption><pre><code>assert(block[0] == ('', [], []))
assert(block[2][1] == '')
node_type = 'link'
node_attrs = {
    'children': unwrap_blocks(block[1]),
    'target': block[2][0]
}
</code></pre></figure><p><code>Span</code> objects consist of an <code>Attr</code> tuple and a list of <code>Inline</code> tokens, much like a header. This gets emitted for <code>TODO</code> items, in which case the class list in the <code>Attr</code> tuple will be <code>['todo', 'TODO']</code>.</p><figure><figcaption>Unwrap Span</figcaption><pre><code>node_type = 'span'
node_attrs = {
    'is-todo': 'todo' in block[0][1],
    'children': unwrap_blocks(block[1])
}
</code></pre></figure><h2>Generating the page content</h2><p>Now that the Org file has been parsed into an AST, the AST can be converted to HTML representing the page content by visiting each node in the AST node list.</p><figure><figcaption>Generate page content from AST</figcaption><pre><code>page_content = ast_to_html(ast)
</code></pre></figure><figure><pre><code>def ast_to_html(ast):
    html = '&lt;div id="content"&gt;'

    &lt;&lt;Process AST nodes&gt;&gt;

    html += '&lt;/div&gt;'

    return html

</code></pre></figure><p>Similarly to the way parsing was handled, each node type will need its own case, with support for recursively converting children.</p><figure><figcaption>Process AST nodes</figcaption><pre><code>html += ast_nodes_to_html(ast[1])
</code></pre></figure><figure><pre><code>def html_escape(s):
    return s.replace('&amp;', '&amp;amp;') \
            .replace('&lt;', '&amp;lt;') \
            .replace('&gt;', '&amp;gt;')

</code></pre></figure><figure><pre><code>def ast_nodes_to_html(nodes):
    html = ''
    for node in nodes:
        html += ast_node_to_html(node)
    return html
</code></pre></figure><figure><pre><code>def ast_node_to_html(node):
    html = ''

    node_type, node_attrs = node

    if node_type == 'org-directive':
        pass
    elif node_type == 'todo-item':
        pass
    elif node_type == 'heading':
        &lt;&lt;Heading to HTML&gt;&gt;
    elif node_type == 'paragraph':
        &lt;&lt;Paragraph to HTML&gt;&gt;
    elif node_type == 'plain-text':
        html += ast_nodes_to_html(node_attrs['children'])
    elif node_type == 'strong-text':
        &lt;&lt;Strong text to HTML&gt;&gt;
    elif node_type == 'emphasized-text':
        &lt;&lt;Emphasized text to HTML&gt;&gt;
    elif node_type == 'ordered-list':
        &lt;&lt;Ordered list to HTML&gt;&gt;
    elif node_type == 'list-item':
        &lt;&lt;List item to HTML&gt;&gt;
    elif node_type == 'inline-code':
        &lt;&lt;Inline code to HTML&gt;&gt;
    elif node_type == 'code-block':
        &lt;&lt;Code block to HTML&gt;&gt;
    elif node_type == 'link':
        &lt;&lt;Link to HTML&gt;&gt;
    elif node_type == 'string':
        html += html_escape(node_attrs['text'])
    elif node_type == 'space':
        html += ' '
    elif node_type == 'soft-break':
        html += ' '
    else:
        print(node)
        raise TypeError(f'Unhandled node type: {node_type}')

    return html

</code></pre></figure><figure><figcaption>Heading to HTML</figcaption><pre><code>n = node_attrs['level']
html += f'&lt;h{n}&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += f'&lt;/h{n}&gt;'
</code></pre></figure><figure><figcaption>Paragraph to HTML</figcaption><pre><code>html += '&lt;p&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += '&lt;/p&gt;'
</code></pre></figure><figure><figcaption>Strong text to HTML</figcaption><pre><code>html += '&lt;strong&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += '&lt;/strong&gt;'
</code></pre></figure><figure><figcaption>Emphasized text to HTML</figcaption><pre><code>html += '&lt;em&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += '&lt;/em&gt;'
</code></pre></figure><figure><figcaption>Ordered list to HTML</figcaption><pre><code>html += '&lt;ol&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += '&lt;/ol&gt;'
</code></pre></figure><figure><figcaption>List item to HTML</figcaption><pre><code>html += '&lt;li&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += '&lt;/li&gt;'
</code></pre></figure><figure><figcaption>Link to HTML</figcaption><pre><code>target = node_attrs['target']
html += f'&lt;a href="{target}"&gt;'
html += ast_nodes_to_html(node_attrs['children'])
html += '&lt;/a&gt;'
</code></pre></figure><figure><figcaption>Inline code to HTML</figcaption><pre><code>html += '&lt;code&gt;'
html += html_escape(node_attrs['text'])
html += '&lt;/code&gt;'
</code></pre></figure><figure><figcaption>Code block to HTML</figcaption><pre><code>name = node_attrs['name']
html += '&lt;figure&gt;'
if len(name) &gt; 0:
    html += '&lt;figcaption&gt;'
    html += html_escape(name)
    html += '&lt;/figcaption&gt;'
html += '&lt;pre&gt;&lt;code&gt;'
html += html_escape(node_attrs['text'])
html += '&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;'
</code></pre></figure><h2>Populating the HTML template</h2><p>Jinja uses an <code>Environment</code> object to manage templates. Thus, at the start of the program, such an <code>Environment</code> is created to load templates from the <code>TEMPLATES_DIR</code> directory and trim whitespace from blocks (see <a href="https://jinja.palletsprojects.com/en/stable/api/#high-level-api">documentation</a> here).</p><figure><pre><code>import jinja2
</code></pre></figure><figure><pre><code>TEMPLATES_DIR = 'templates'
</code></pre></figure><figure><figcaption>Set up Jinja environment</figcaption><pre><code>jinja_env = jinja2.Environment(
    loader=jinja2.FileSystemLoader(TEMPLATES_DIR),
    trim_blocks=True,
    lstrip_blocks=True
)
</code></pre></figure><p>When it comes time to actually render a page, we use the Jinja <code>Environment</code> created earlier to load the template (AFAIK Jinja handles caching for us), then use the template to render the final output.</p><figure><pre><code>def render_page(template, *args, **kwargs):
    jinja_template = jinja_env.get_template(template)
    return jinja_template.render(*args, **kwargs)

</code></pre></figure><figure><figcaption>Create page from Template</figcaption><pre><code>page_html = render_page('page.html', metadata, content=page_content)
</code></pre></figure><h2>Writing the page to file</h2><p>First, I ensure the build directory exists and is empty.</p><figure><pre><code>import shutil
</code></pre></figure><figure><pre><code>BUILD_DIR = 'build'
</code></pre></figure><figure><pre><code>def make_dir(path):
    """ Create a directory (and all necessary parent directories)
        if it does not already exist.
    """
    os.makedirs(path, exist_ok=True)

</code></pre></figure><figure><pre><code>def del_dir(root):
    """ Delete the contents of a directory.
    """
    for itemname in os.listdir(root):
        itempath = os.path.join(root, itemname)
        if os.path.isdir(itempath):
            shutil.rmtree(itempath)
        else:
            os.remove(itempath)
</code></pre></figure><figure><figcaption>Ensure build directory exists</figcaption><pre><code>make_dir(BUILD_DIR)
del_dir(BUILD_DIR)
</code></pre></figure><p>Then, I copy over static files (such as stylesheets).</p><figure><pre><code>STYLES_DIR = 'styles'
</code></pre></figure><figure><pre><code>def copy_dir(indir, outdir):
    """ Copy the contents of one directory to another
    """
    shutil.copytree(indir, outdir, dirs_exist_ok=True)

</code></pre></figure><figure><figcaption>Copy static files to build directory</figcaption><pre><code>outdir = os.path.join(BUILD_DIR, STYLES_DIR)
copy_dir(STYLES_DIR, outdir)
</code></pre></figure><figure><pre><code>def path_join(*args):
    return os.path.join(*args)

</code></pre></figure><figure><pre><code>def write_to_file(fpath, string):
    with open(fpath, 'w+', encoding='utf-8') as f:
        f.write(string)

</code></pre></figure><figure><figcaption>Write page to file</figcaption><pre><code>url = fname + '.html'
outpath = path_join(BUILD_DIR, url)
write_to_file(outpath, page_html)

metadata['url'] = url
pages.append(metadata)
</code></pre></figure><h2>Generating the home page</h2><p>Last but not least, I generate the home page.</p><figure><figcaption>Generate home page</figcaption><pre><code>homepage_html = render_page('index.html', title='Home', pages=pages)
outpath = os.path.join(BUILD_DIR, 'index.html')
write_to_file(outpath, homepage_html)
</code></pre></figure></div>

    <div id="home-button" class="ui-button">
        üè†
        <a href="index.html"></a>
    </div>
</div>
    <div id="footer">
    </div>
</body>
</html>